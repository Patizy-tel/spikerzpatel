import {
  Component,
  ElementRef,
  inject,
  OnInit,
  output,
  viewChild,
  AfterViewInit,
} from '@angular/core';
import { NgxGraphModule, NgxGraphZoomOptions } from '@swimlane/ngx-graph';
import { Subject } from 'rxjs';
import { VulnerabilityStore, PopoverPosition } from '../../../core/services';
import { GraphNode } from '../../../core/models';

@Component({
  selector: 'app-network-graph',
  standalone: true,
  imports: [NgxGraphModule],
  template: `
    <div class="graph-container" #graphContainer>
      <ngx-graph
        class="chart-container"
        [links]="store.graphEdges()"
        [nodes]="store.graphNodes()"
        [zoomToFit$]="zoomToFit$"
        [center$]="center$"
        [enableZoom]="true"
        [autoZoom]="true"
        [autoCenter]="true"
        layout="dagre"
        [layoutSettings]="{
          orientation: 'LR',
          rankSeparation: 120,
          nodeSeparation: 60
        }"
      >
        <!-- Node Template - Card Style -->
        <ng-template #nodeTemplate let-node>
          <svg:g
            class="node-group"
            (click)="onNodeClick($event, node)"
          >
            <!-- Glow effect for critical nodes -->
            @if (node.data?.risk === 'critical') {
              <svg:rect
                x="-64"
                y="-39"
                width="128"
                height="78"
                rx="10"
                fill="none"
                stroke="#dc2626"
                stroke-width="2"
                class="critical-glow"
                opacity="0.6"
              />
            }

            <!-- Card background with subtle gradient -->
            <svg:rect
              x="-60"
              y="-35"
              width="120"
              height="70"
              rx="8"
              [attr.fill]="getCardBgColor(node)"
              [attr.stroke]="getCardStrokeColor(node)"
              stroke-width="1.5"
              class="node-card"
            />

            <!-- Server icon container -->
            <svg:rect
              x="-50"
              y="-25"
              width="36"
              height="36"
              rx="6"
              [attr.fill]="getIconBgColor(node)"
            />

            <!-- Server icon - stacked server visual -->
            <svg:rect x="-44" y="-18" width="24" height="4" rx="1" fill="white" opacity="0.95" />
            <svg:rect x="-44" y="-11" width="24" height="4" rx="1" fill="white" opacity="0.95" />
            <svg:rect x="-44" y="-4" width="24" height="4" rx="1" fill="white" opacity="0.95" />

            <!-- LED indicators on server icon -->
            <svg:circle cx="-40" cy="-16" r="1.5" fill="#22c55e" class="led-blink" />
            <svg:circle cx="-40" cy="-9" r="1.5" fill="#22c55e" class="led-blink" style="animation-delay: 0.3s" />
            <svg:circle cx="-40" cy="-2" r="1.5" [attr.fill]="node.data?.risk === 'critical' ? '#ef4444' : '#22c55e'" class="led-blink" style="animation-delay: 0.6s" />

            <!-- Node name -->
            <svg:text
              x="-8"
              y="-10"
              font-size="10"
              font-weight="600"
              fill="#1e293b"
              class="node-name"
            >
              {{ truncateName(node.label) }}
            </svg:text>

            <!-- IP Address -->
            <svg:text
              x="-8"
              y="4"
              font-size="9"
              fill="#64748b"
              class="node-ip"
            >
              {{ node.data?.ipAddress || '' }}
            </svg:text>

            <!-- Risk level badge -->
            <svg:g transform="translate(-8, 12)">
              <svg:rect
                width="40"
                height="14"
                rx="7"
                [attr.fill]="getRiskBadgeColor(node)"
                opacity="0.15"
              />
              <svg:text
                x="20"
                y="10"
                text-anchor="middle"
                font-size="8"
                font-weight="600"
                [attr.fill]="getRiskBadgeColor(node)"
              >
                {{ (node.data?.risk || 'low').toUpperCase() }}
              </svg:text>
            </svg:g>

            <!-- Critical/High alert indicator -->
            @if (node.data?.risk === 'critical' || node.data?.risk === 'high') {
              <svg:g transform="translate(48, -28)">
                <svg:circle
                  r="14"
                  [attr.fill]="node.data?.risk === 'critical' ? '#dc2626' : '#f97316'"
                  class="pulse-ring"
                  opacity="0.3"
                />
                <svg:circle
                  r="11"
                  [attr.fill]="node.data?.risk === 'critical' ? '#dc2626' : '#f97316'"
                  stroke="white"
                  stroke-width="2"
                />
                <svg:text
                  text-anchor="middle"
                  dominant-baseline="central"
                  fill="white"
                  font-size="11"
                  font-weight="bold"
                >
                  {{ node.data?.risk === 'critical' ? '!' : 'âš ' }}
                </svg:text>
              </svg:g>
            }
          </svg:g>
        </ng-template>

        <!-- Link Template with animated flow -->
        <ng-template #linkTemplate let-link>
          <svg:g class="edge-group">
            <!-- Base path -->
            <svg:path
              [attr.d]="link.line"
              stroke="#cbd5e1"
              stroke-width="3"
              fill="none"
              stroke-linecap="round"
            />
            <!-- Animated flow path -->
            <svg:path
              [attr.d]="link.line"
              stroke="url(#edgeGradient)"
              stroke-width="2"
              fill="none"
              stroke-linecap="round"
              stroke-dasharray="8 4"
              class="animated-edge"
              marker-end="url(#arrowMarker)"
            />
          </svg:g>
        </ng-template>

        <!-- Defs Template for gradients and markers -->
        <ng-template #defsTemplate>
          <!-- Arrow marker -->
          <svg:marker
            id="arrowMarker"
            viewBox="0 0 10 10"
            refX="8"
            refY="5"
            markerWidth="6"
            markerHeight="6"
            orient="auto"
          >
            <svg:path d="M 0 0 L 10 5 L 0 10 z" fill="#64748b" />
          </svg:marker>

          <!-- Edge gradient -->
          <svg:linearGradient id="edgeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <svg:stop offset="0%" stop-color="#94a3b8" />
            <svg:stop offset="50%" stop-color="#64748b" />
            <svg:stop offset="100%" stop-color="#475569" />
          </svg:linearGradient>

          <!-- Critical node glow filter -->
          <svg:filter id="criticalGlow" x="-50%" y="-50%" width="200%" height="200%">
            <svg:feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <svg:feMerge>
              <svg:feMergeNode in="coloredBlur"/>
              <svg:feMergeNode in="SourceGraphic"/>
            </svg:feMerge>
          </svg:filter>
        </ng-template>
      </ngx-graph>
    </div>
  `,
  styles: `
    :host {
      display: block;
      width: 100%;
      height: 100%;
    }

    .graph-container {
      width: 100%;
      height: 100%;
      min-height: 22rem;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      border-radius: var(--radius-lg);
      overflow: hidden;
      position: relative;
    }

    .chart-container {
      width: 100%;
      height: 100%;
    }

    .node-group {
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .node-group:hover {
      transform: scale(1.02);
    }

    .node-card {
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.08));
      transition: all 0.2s ease;
    }

    .node-group:hover .node-card {
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.12));
    }

    .node-name {
      font-family: var(--font-sans);
    }

    .node-ip {
      font-family: var(--font-mono);
    }

    .edge-group {
      pointer-events: none;
    }

    /* Animated flowing edge */
    .animated-edge {
      animation: flowAnimation 2s linear infinite;
    }

    @keyframes flowAnimation {
      0% {
        stroke-dashoffset: 24;
      }
      100% {
        stroke-dashoffset: 0;
      }
    }

    /* Critical node glow animation */
    .critical-glow {
      animation: glowPulse 2s ease-in-out infinite;
    }

    @keyframes glowPulse {
      0%, 100% {
        opacity: 0.4;
        stroke-width: 2;
      }
      50% {
        opacity: 0.8;
        stroke-width: 3;
      }
    }

    /* Pulse ring animation for alert badges */
    .pulse-ring {
      animation: pulseRing 1.5s ease-out infinite;
      transform-origin: center;
    }

    @keyframes pulseRing {
      0% {
        transform: scale(1);
        opacity: 0.4;
      }
      100% {
        transform: scale(1.8);
        opacity: 0;
      }
    }

    /* LED blink animation */
    .led-blink {
      animation: ledBlink 1.5s ease-in-out infinite;
    }

    @keyframes ledBlink {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.4;
      }
    }

    /* ========== RESPONSIVE STYLES ========== */

    /* Tablets */
    @media (max-width: 1024px) {
      .graph-container {
        min-height: 20rem;
      }
    }

    /* Mobile landscape and small tablets */
    @media (max-width: 768px) {
      .graph-container {
        min-height: 16rem;
        border-radius: var(--radius-md);
        touch-action: pan-x pan-y;
      }

      .node-group:hover {
        transform: none;
      }

      .node-group:active {
        transform: scale(0.98);
      }
    }

    /* Mobile portrait */
    @media (max-width: 480px) {
      .graph-container {
        min-height: 12rem;
      }

      /* Reduce animation complexity on mobile for performance */
      .animated-edge {
        animation-duration: 3s;
      }

      .pulse-ring {
        animation: none;
        opacity: 0.3;
      }

      .critical-glow {
        animation: none;
        opacity: 0.5;
      }
    }

    /* Very small screens */
    @media (max-width: 360px) {
      .graph-container {
        min-height: 10rem;
      }
    }

    /* Landscape orientation on mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .graph-container {
        min-height: 8rem;
      }
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce) {
      .animated-edge,
      .pulse-ring,
      .critical-glow,
      .led-blink {
        animation: none;
      }

      .node-group,
      .node-card {
        transition: none;
      }
    }

    /* Touch devices - larger touch targets */
    @media (hover: none) and (pointer: coarse) {
      .node-group {
        cursor: default;
      }
    }
  `,
})
export class NetworkGraphComponent implements OnInit, AfterViewInit {
  store = inject(VulnerabilityStore);

  nodeClick = output<{ node: GraphNode; position: PopoverPosition }>();

  graphContainer = viewChild<ElementRef<HTMLDivElement>>('graphContainer');

  zoomToFit$ = new Subject<NgxGraphZoomOptions>();
  center$ = new Subject<boolean>();

  ngOnInit(): void {
    // Initial setup
  }

  ngAfterViewInit(): void {
    setTimeout(() => {
      this.zoomToFit$.next({ autoCenter: true, force: true });
      this.center$.next(true);
    }, 100);
  }

  getIconBgColor(node: GraphNode): string {
    const colorMap: Record<string, string> = {
      critical: '#dc2626',
      high: '#f97316',
      medium: '#3b82f6',
      low: '#22c55e',
    };
    return colorMap[node.data?.risk] || '#64748b';
  }

  getCardBgColor(node: GraphNode): string {
    const colorMap: Record<string, string> = {
      critical: '#fef2f2',
      high: '#fff7ed',
      medium: '#f8fafc',
      low: '#f0fdf4',
    };
    return colorMap[node.data?.risk] || '#ffffff';
  }

  getCardStrokeColor(node: GraphNode): string {
    const colorMap: Record<string, string> = {
      critical: '#fecaca',
      high: '#fed7aa',
      medium: '#e2e8f0',
      low: '#bbf7d0',
    };
    return colorMap[node.data?.risk] || '#e2e8f0';
  }

  getRiskBadgeColor(node: GraphNode): string {
    const colorMap: Record<string, string> = {
      critical: '#dc2626',
      high: '#f97316',
      medium: '#3b82f6',
      low: '#22c55e',
    };
    return colorMap[node.data?.risk] || '#64748b';
  }

  truncateName(name: string): string {
    return name.length > 16 ? name.substring(0, 14) + '...' : name;
  }

  onNodeClick(event: MouseEvent, node: GraphNode): void {
    event.stopPropagation();

    const container = this.graphContainer()?.nativeElement;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    const position: PopoverPosition = {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top,
    };

    this.store.selectNode(node, position);
    this.nodeClick.emit({ node, position });
  }
}

import {
  Component,
  ElementRef,
  inject,
  OnInit,
  output,
  viewChild,
  AfterViewInit,
} from '@angular/core';
import { NgxGraphModule, NgxGraphZoomOptions } from '@swimlane/ngx-graph';
import { Subject } from 'rxjs';
import { VulnerabilityStore, PopoverPosition } from '../../../core/services';
import { GraphNode } from '../../../core/models';

@Component({
  selector: 'app-network-graph',
  standalone: true,
  imports: [NgxGraphModule],
  template: `
    <div class="graph-container" #graphContainer>
      <ngx-graph
        class="chart-container"
        [links]="store.graphEdges()"
        [nodes]="store.graphNodes()"
        [zoomToFit$]="zoomToFit$"
        [center$]="center$"
        [enableZoom]="true"
        [autoZoom]="true"
        [autoCenter]="true"
        layout="dagre"
        [layoutSettings]="{
          orientation: 'LR',
          rankSeparation: 100,
          nodeSeparation: 80
        }"
      >
        <!-- Node Template - Card Style -->
        <ng-template #nodeTemplate let-node>
          <svg:g
            class="node-group"
            (click)="onNodeClick($event, node)"
          >
            <!-- Card background -->
            <svg:rect
              x="-60"
              y="-35"
              width="120"
              height="70"
              rx="8"
              fill="white"
              stroke="#e2e8f0"
              stroke-width="1"
              class="node-card"
            />

            <!-- Server icon container -->
            <svg:rect
              x="-50"
              y="-25"
              width="36"
              height="36"
              rx="6"
              [attr.fill]="getIconBgColor(node)"
            />

            <!-- Server icon lines -->
            <svg:rect x="-44" y="-18" width="24" height="4" rx="1" fill="white" opacity="0.9" />
            <svg:rect x="-44" y="-11" width="24" height="4" rx="1" fill="white" opacity="0.9" />
            <svg:rect x="-44" y="-4" width="24" height="4" rx="1" fill="white" opacity="0.9" />

            <!-- Node name -->
            <svg:text
              x="-8"
              y="-8"
              font-size="11"
              font-weight="600"
              fill="#1e293b"
              class="node-name"
            >
              {{ truncateName(node.label) }}
            </svg:text>

            <!-- IP Address -->
            <svg:text
              x="-8"
              y="8"
              font-size="10"
              fill="#64748b"
              class="node-ip"
            >
              {{ node.data?.ipAddress || '' }}
            </svg:text>

            <!-- Critical badge indicator -->
            @if (node.data?.risk === 'critical') {
              <svg:g transform="translate(48, -28)">
                <svg:circle r="12" fill="#dc2626" stroke="white" stroke-width="2" />
                <svg:text
                  text-anchor="middle"
                  dominant-baseline="central"
                  fill="white"
                  font-size="10"
                  font-weight="bold"
                >
                  !
                </svg:text>
              </svg:g>
            }
          </svg:g>
        </ng-template>

        <!-- Link Template with arrow -->
        <ng-template #linkTemplate let-link>
          <svg:g class="edge-group">
            <svg:path
              [attr.d]="link.line"
              stroke="#94a3b8"
              stroke-width="2"
              fill="none"
              marker-end="url(#arrow)"
            />
          </svg:g>
        </ng-template>
      </ngx-graph>

      <!-- Arrow marker definition -->
      <svg class="defs-only">
        <defs>
          <marker
            id="arrow"
            viewBox="0 0 10 10"
            refX="9"
            refY="5"
            markerWidth="6"
            markerHeight="6"
            orient="auto-start-reverse"
          >
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
          </marker>
        </defs>
      </svg>
    </div>
  `,
  styles: `
    :host {
      display: block;
      width: 100%;
      height: 100%;
    }

    .graph-container {
      width: 100%;
      height: 100%;
      min-height: 18rem;
      background-color: var(--color-bg-secondary);
      border-radius: var(--radius-lg);
      overflow: hidden;
      position: relative;
    }

    .chart-container {
      width: 100%;
      height: 100%;
    }

    .defs-only {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
    }

    .node-group {
      cursor: pointer;
    }

    .node-card {
      filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.1));
      transition: filter 0.2s ease;
    }

    .node-group:hover .node-card {
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.15));
    }

    .node-name {
      font-family: var(--font-sans);
    }

    .node-ip {
      font-family: var(--font-mono);
    }

    .edge-group {
      pointer-events: none;
    }
  `,
})
export class NetworkGraphComponent implements OnInit, AfterViewInit {
  store = inject(VulnerabilityStore);

  nodeClick = output<{ node: GraphNode; position: PopoverPosition }>();

  graphContainer = viewChild<ElementRef<HTMLDivElement>>('graphContainer');

  zoomToFit$ = new Subject<NgxGraphZoomOptions>();
  center$ = new Subject<boolean>();

  ngOnInit(): void {
    // Initial setup
  }

  ngAfterViewInit(): void {
    setTimeout(() => {
      this.zoomToFit$.next({ autoCenter: true, force: true });
      this.center$.next(true);
    }, 100);
  }

  getIconBgColor(node: GraphNode): string {
    const colorMap: Record<string, string> = {
      critical: '#fecaca',
      high: '#fed7aa',
      medium: '#bfdbfe',
      low: '#bbf7d0',
    };
    return colorMap[node.data?.risk] || '#bfdbfe';
  }

  truncateName(name: string): string {
    return name.length > 16 ? name.substring(0, 14) + '...' : name;
  }

  onNodeClick(event: MouseEvent, node: GraphNode): void {
    event.stopPropagation();

    const container = this.graphContainer()?.nativeElement;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    const position: PopoverPosition = {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top,
    };

    this.store.selectNode(node, position);
    this.nodeClick.emit({ node, position });
  }
}
